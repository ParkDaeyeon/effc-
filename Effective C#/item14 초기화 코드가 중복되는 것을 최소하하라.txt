item 14 초기화 코드가 중복되는 것을 최소화하라


생성자를 작성하다 보면 종종 동일한 작업을 되풀이할 때가 있어서 기존에 작성한 코드를 그대로 복사하곤 한다.
지금까지 이런 방식으로 생성자를 작성했다면 더 이상은 그렇게 하지 않기를 바란다.
노련한 C++ 개발자들은 여러 생성자 내에서 공통적으로 수행하는 코드 블록을 private 헬퍼 메서드로 분리한 후 이 메서드를 호출하도록 작성하곤 한다.
C#을 이용해 개발하는 경우라면 이 또한 권장할만한 방법이 아니다.
여러 생성자 내에서 동일한 코드를 반복적으로 사용해야 한다면 C++에서와 같이 private 헬퍼 메서드를 작성하기보다는 공용으로 사용할 수 있는 생성자를 작성하는 편이 낫다. 
이렇게 하면 코드가 중복되는 것을 피할 수 있을 뿐 아니라 더 효율적으로 수행되는 생성자를 작성할 수 있다.
C# 컴파일러는 공용 생성자를 이용하는 초기화 방식을 매우 특별한 문법으로 인식한다. 
변수에 대한 중복 초기화 코드를 제거해 줄 뿐 아니라 베이스 클래스의 생성자가 반복적으로 호출되는 것도 막아준다.
즉 객체 초기화를 위해 수행해야 하는 코드를 최적화해준다. 
개발자 입장에서는 초기화 과정 일부를 공용 생성자에 위임할 수 있으므로 작성하는 코드의 양을 최소화할 수 있다.

생성자를 이용하여 멤버 변수의 값을 초기화하는 경우라면 다른 생성자를 호출하여 초기화 과정의 일부를 위임할 수 있다.
다음에 간단한 예를 나타냈다.

public class MyClass
{
	// 데이터 컬랙션
	private List<ImportantData> coll;
	
	// 인스턴스 변수
	private string name;

	public MyClass() : this(0, "")
	{
	}
	
	public MyClass(int initialCount) : this(initialCount, string.Empty)
	{
	}
	
	public MyClass(int initialCount, string name) 
	{
		// 구현
	}
}

C# 4.0에 추가된 기본 매개변수 기능을 활용하면 생성자 내의 중복 코드를 더욱 줄일 수 있따.
MyClass 내에 있는 여러 개의 생성자를 기본값을 가진 매개변수를 취하는 생성자 하나로 대체할 수 있기 때문이다.

public class MyClass
{
	// 데이터 컬렉션
	private List<ImportantDat> coll;
	
	// 인스턴스 변수
	private string name;
	
	// new () 제약 조건을 만족시키려면 이 생성자가 필요하다.
	public MyClass() : this(0, string.Empty)
	{
	}

	public MyClass(int initialCount = 0, string name = "")
	{
		// 구현
	}

}

여러 개의 생성자를 작성하는 대신 기본값을 갖는 매개변수를 취하는 생성자를 작성할 때는 몇 가지 트레이드오프를 고려해야 한다.
우선 기본값을 갖는 매개변수는 사용자에게 더 많은 옵션을 제공한다.
앞의 예제에서는 두 매개변수에 대하여 기본값을 지정했으므로 사용자는 매개변수를 지정하지 않거나, 하나 혹은 둘 모두에 임의의 값을 지정할 수 있다.
이 기능이 없었다면 4개의 생성자를 만들어야 했을 것이다(매개변수가 없는 생성자, initialCount 값만을 취하는 생성자, name 값만을 취하는 생성자, 두 매개변수를 모두 취하는 생성자). 
클래스에 멤버 변수를 추가하고 또 이를 초기화하기 위해 생성자를 추가하다 보면 다양한 조합의 생성자를 만들어야 하는 경우가 생기곤 한다. 
이로 인해 코드의 구조가 복잡해지기 쉬운데 기본값을 가진 매개변수를 취하는 생성자를 활용하면 코드의 양을 최소화할 수 있다.

생성자의 모든 매개변수에 대해서 기본값을 정의한 경우 new MyClass()라고만 작성해도 유효한 코드가 된다. 
하지만 어떤 경우에도 제한 없이 이런 구조를 사용하려면 앞의 예제 코드처럼 매개변수가 없는 생성자를 명시적으로 작성해야한다.
대부분의 경우 기본값을 가지는 매개변수를 취하는 생성자가 사용될 것이므로 큰 문제가 없다. 
그러나 new() 제약 조건을 명시한 제네릭 클래스와 함께 사용해야 할 경우에는 기본값을 가지는 매개변수를 취하는 생성자만으로는 이 제약 조건을 만족시킬 수 없으며 반드시 매개변수가 없는 생성자를 구현해야 한다.
당연한 이야기지만 모든 타입이 매개변수가 없는 생성자를 반드시 가져야 할 이유는 없으며 단지 new() 제약 조건을 만족시키려면 매개변수가 없는 생성자가 필요하다는 것이다.

앞 코드의 생성자를 유심히 살펴보면 name 매개변수의 기본값을 string.Empty가 아니라 ""로 지정한 것을 알 수 있다. 
여기서 string.Empty를 사용할 수 없는 이유는 이 값이 컴파일 타임 상수가 아니라 string 클래스에서 정의하고 있는 정적 속성이기 때문이다. 
매개변수의 기본값으로는 컴파일 타임 상수만을 지정할 수 있다.

반면, 여러 개의 생성자를 만드는 대신 기본값을 갖는 매개변수를 취하는 생성자를 작성하게 되면 이 타입을 사용하는 코드와의 결합도가 높아지는 단점도 있다. 
기본값을 갖는 매개변수를 사용하면 형식 매개변수의 이름과 매개변수의 기본값이 모두 공개 인터페이스의 일부가 된다.
이로 인해 매개변수의 이름을 변경하면 이 타입을 사용하는 모든 코드를 다시 컴파일해야 한다.
머지 않아 코드를 변경할 수도 있는 상황이라면 기본값을 갖는 매개변수를 사용하는 것보다 기존 방식과 같이 여러 생성자를 오버로딩하는 편이 나을 수도 있다.
이 경우 새로운 생성자를 추가하거나 기존 동작 방식을 변경하더라도 클라이언트 코드를 다시 컴파일할 필요가 없기 때문이다.

생성자를 정의할 때 기본값을 갖는 매개변수를 사용하는 방법은 널리 사용되는 방식이지만 일부 API는 리플렉션을 통해 객체를 생성하기 때문에 매개변수가 없는 생성자가 반드시 필요한 경우가 있다. 
사용자 측면에서 보자면 매개변수가 없는 생성자는 모든 매개변수에 대해 기본값을 제공하는 생성자와 비슷해 보인다. 
하지만 컴파일러는 이 둘을 완전히 동일한 것으로 간주하지 않는다. 
따라서 어떤 경우에는 매개변수가 없는 생성자를 추가로 작성해야할 수도 있다. 
이 경우 중복 코드를 피하기 위해서 공통으로 사용하는 유틸리티 메서드를 만들 수도 있지만 앞의 예제에서와 같이 생성자 체인 기법을 이용하는 것이 낫다. 
생성자 체인 기법이란 임의의 생성자가 동일 클래스 내에 정의된 다른 생성자를 호출하는 방식을 말한다. 
여러 생성자에서 공통으로 사용하는 코드를 다른 메서드로 분리하는 방법은 일부 비효율적인 측면이 있다.

public class MyClass
{
	private List<ImportantData> coll;
	private string name;
	
	public MyClass()
	{
		commonConstructor(0,"");
	}

	public MyClass(int initialCount)
	{
		commonConstructor(initialCount, "");
	}

	public MyClass(int initialCount, string Name)
	{
		commonConstructor(initialCount, Name);
	}

	private void commonConstructor(int count, string name)
	{
		// 구현
	}
}



이 코드는 첫 번째 예와 동일한 듯 보이지만 훨씬 비효율적인 코드를 생성한다. 
실제로 컴파일러는 이 코드를 컴파일할 때 사용자가 작성하지 않은 코드를 추가한다. 
먼저 모든 인스턴스 변수에 대한 초기화 코드가 추가된다. 
다음으로 베이스 클래스의 생성자를 호출하는 코드가 추가되고, 
마지막으로 사용자가 작성한 공용 유틸리티 함수를 호출하는 코드가 포함된다. 
컴파일러는 이 과정에서 중복코드를 제거하지 못한다. 
다음 코드는 컴파일러가 생성한 IL 코드를 C# 코드로 변경한 예다.

public class MyClass
{
	private List<ImportantData> coll;
	private string name;

	public MyClass()
	{
		// 인스턴스 초기화 코드가 이 위치에 포함된다.
		object(); // 설명을 위한 코드 유효한 코드는 아니다.
		commonConstructor(0, "");
	}
	
	public MyClass(int initialCount)
	{
		// 인스턴스 초기화 코드가 이 위치에 포함된다.
		object(); // 설명을 위한 코드, 유효한 코드는 아니다.
		commonConstructor(initialCount, "");
	}

	public MyClass(int initialCount, string Name)
	{
		// 인스턴스 초기화 코드가 이 위치에 포함된다.
		object(); // 설명을 위한 코드, 유효한 코드는 아니다.
		commonConstructor(initialCount, Name);
	}
	
	private void commonConstructor(int count, string name)
	{
		// 구현
	}	
}



이번 아이템의 첫 번째 예에 대해서도 컴파일러가 생성한 IL 코드를 C# 코드로 변경해 봤다.

// 유효한 코드는 아님
// IL 로 생성된 코드를 설명하기 위한 용도이다.
public class MyClass
{
	private List<ImportantData> coll;
	private string name;

	public MyClass()
	{
		// 변수에 대한 초기화 코드가 없다.
		// 다음과 같이 다른 생성자를 호출한다.
		this (0, ""); // 설명을 위한 코드, 유효한 코드는 아니다.
	}

	public MyClass(int initialCount)
	{
		// 변수에 대한 초기화 코드가 없다.
		// 다음과 같이 다른 생성자를 호출한다.
		this (initialCount), ""); // 설명을 위한 코드, 유효한 코드는 아니다.
	}

	public MyClass(int initialCount, string Name)
	{
		// 구현
	}
}

두 코드의 차이는 베이스 클래스의 생성자를 호출하는 코드와 인스턴스 변수를 초기화하는 코드가 각각의 생성자에 모두 포함되지 않는다는 점이다. 
마지막으로 호출되는 생성자에서만 베이스 클래스의 생성자가 호출된다는 점도 중요하다. 
각각의 생성자별로 생성자 초기화 구문은 한 번만 사용할 수 있으므로 this()를 이용하여 이 클래스 내의 다른 생성자를 호출하거나 base()를 이용하여 베이스 클래스 생성자를 호출할 수 있다. 
두 가지를 함께 사용할 수는 없다.

아직도 생성자 초기화 구문이 마땅치 않은가? 
그렇다면 읽기 전용 상수에 대해서도 추가로 살펴보자. 
다음 예제에서 name 필드는 객체 생성 이후에는 변경할 수 없도록 readonly로 선언했다. 
만약 공통 유틸리티 함수를 사용하여 이 필드의 값을 초기화하려고 하면 컴파일 오류가 발생한다.

public class MyClass
{
	// 데이터 컬랙션
	private List<ImportantData> coll;
	
	// 인스턴스 개수
	private int counter;
	
	// 인스턴스 이름
	private readonly string name;
	
	public MyClass()
	{
		commonConstructor(0, string.Empty);
	}
	
	public MyClas(int initialCount)
	{
		commonConstructor(initialCount, string.Empty);
	}
	
	public MyClass(int initialCount, string Name)
	{
		commonConstructor(initialCount, Name);
	}
	
	private void commonConstructor(int count, string name)
	{
		//구현
		
		// 오류! 생성자 외부에서 readonly로 선언된 name의 값을 변경할 수 없다.
		this.name = name;
	}
}

컴파일러는 this.name을 읽기 전용으로 만든다.
이 경우 생성자 외부에서는 이 변수의 값을 변경할 수 없다. 
이 경우 C#의 생성자 초기화 구문이 상당히 효율적인 대안이 될 수 있다. 
굉장히 단순한 클래스를 제외한다면 대부분의 클래스는 하나 이상의 생성자를 가지곤 한다. 
하지만 이 경우에도 모든 생성자가 객체 초기화라는 본질적인 역할을 수행해야 하므로 유사한 코드가 반복적으로 나타날 수밖에 없다. 
C#의 생성자 초기화 구문을 사용하면 공통 코드를 공용 생성자로 옮기고 다른 생성자에서는 이를 호출하도록 코드를 구성할 수 있다.

생성자를 작성할 때 기본값을 가지는 매개변수를 사용하는 방법과 다수의 생성자를 오버로딩하는 방법은 각기 적합한 용도가 있다. 
일반적으로 여러 개의 생성자를 오버로딩하기보다는 기본값을 가지는 매개변수를 사용하여 생성자를 작성하는 것이 좋다. 
이 경우 사용자 입장에서는 생성자의 모든 매개변수에 원하는 값을 전달하거나 매개변수 중 일부에만 임의의 값을 전달할 수도 있다. 
매개변수의 기본값은 합리적으로 지정돼야 하고 예외를 유발해서는 안 된다. 
매개변수의 기본값을 변경하는 것이 기술적으로 큰 변화인 경우라도 이를 사용하는 사용자에게는 어떠한 영향도 미쳐서는 안 된다. 
사용자는 변경 이전의 기본값을 계속 사용할 수 있어야 하며 이 경우에도 올바르게 동작해야 한다. 
이는 잠재적인 위험을 최소화화기 위한 기본 전제다.

이번 아이템이 C# 객체 초기화를 다루는 마지막 아이템이므로 특정 타입의 인스턴스가 생성되는 전체 순서를 다시 한 번 정리하고자 한다. 
C# 개발자라면 인스턴스가 생성되는 순서뿐 아니라 객체의 기본 초기화 과정의 순서도 반드시 알아야 한다. 
그리고 인스턴스가 생성되는 동안 모든 멤버 변수들을 가능한 한 이른 시점에 수행하는 방식을 적용해보는 것도 좋다. 
다음에 특정 타입으로 첫 번째 인스턴스를 생성할 때 수행되는 과정을 단계별로 나열했다.

1. 정적 변수의 저장 공간을 0으로 초기화
2. 정적 변수에 대한 초기화 구문 수행
3. 베이스 클래스의 정적 생성자 수행
4. 정적 생성자 수행
5. 인스턴스 변수의 저장 공간을 0으로 초기화
6. 인스턴스 변수에 대한 초기화 구문 수행
7. 적절한 베이스 클래스의 인스턴스 생성자 수행
8. 인스턴스 생성자 수행

클래스 자체에 대한 초기화 작업은 단 한 번만 이뤄지기 때문에 동일한 타입으로 추가 인스턴스를 생성하면 앞의 단계중 5단계에서부터 수행된다. 
또한 컴파일러가 생성자 내에 중복된 멤버 초기화 코드를 생성하지 않도록 6단계와 7단계는 최적화되어 있다.

C#은 객체가 생성될 때 어떤 식으로든 모든 객체가 초기화될 것임을 보장한다. 
인스턴스를 생성하면 인스턴스 내의 모든 멤버들이(정적 멤버, 인스턴스 멤버를 가리지 않고) 최소한 0으로 초기화된다. 
생성자를 작성할 때 유념할 부분은 멤버들을 원하는 값으로 초기화할 때 가능한 한 한 번만 초기화가 이뤄지도록 해야 한다는 점이다. 
이를 위해서 단순한 리소스의 경우 멤버 초기화 구문을 이용하고 복잡한 초기화 과정이 필요한 경우에만 생성자를 사용하는 것도 좋은 방법이다.
또한 코드의 중복을 피하기 위해서 공통적인 초기화 작업을 수행하는 공용 생성자를 작성하고 이 생성자를 이용하는 방식을 사용하기 바란다.





















































