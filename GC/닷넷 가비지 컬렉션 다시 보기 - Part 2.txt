http://www.simpleisbest.net/post/2011/04/05/Generational-Garbage-Collection.aspx

Generational Garbage Collection

세대별 가비지 컬렉션 내용은 앞으로 다루게 될 Finalizer나 Dispose 패턴 등을 이해하는데 매우 중요할 뿐더러, 닷넷 어플리케이션의 메모리 문제를 분석하는데도 매우 중요한 요소이다. 

1. 세대별 가비지 컬렉션이란? -----------------------------------------------------------------
관리되는 힙(managed heap) 상의 객체를 객체의 생존 시간(live time)에 따라 몇 세대(generation)로 구분하여 가비지 컬렉션을 수행하는 것을 말한다.
즉, 최근에 생성된 객체는 0 세대(Gen 0)가 되며 1회의 GC 동안 살아남은(?) 객체는 1세대(Gen 1), 2회 이상의 GC 동안 살아남은 객체는 2세대(Gen 2)가 되는 방식이다

현재 닷넷 프레임워크의 버전에서 최고의 세대는 2세대이며 2세대의 객체들은 GC가 수행되는 동안 계속 2세대에 남게 된다.

닷넷의 GC는 0 세대에 대해 집중적으로 가비지 컬렉션을 수행한다. 
이렇게 0 세대에 대해 집중적으로 가비지 컬렉션을 수행하면 GC의 성능과 효율을 올릴 수 있는데, 그 근거는 다음과 같다.
- 최근 생성된 객체일수록 생명주기는 짧다. (작은 객체일수록 생성된 후 짧은 시간 동안 사용되고 더 이상 사용되지 않는다)
- 오래된 객체일수록 생명주기는 길다.
- 최근에 생성된 객체들끼리는 서로 연관성이 높으며(참조 관계) 비슷한 시점에서 자주 액세스 된다.
- 일부분의 힙을 가비지 컬렉션 하는 것은 전체를 가비지 컬렉션 하는 것보다 빠르다.

프로그램이 메모리를 임시적으로만 사용하는 것은 아니다. 클래스의 정적 필드(static field)에 기록된 객체들은 명시적으로 해당 필드에 null 을 할당하지 않는 한 결코 사라지지 않는다. 



2. GC 0 -----------------------------------------------------------------------------------------
new(혹은 CreateInstance 등의 객체 생성 메쏘드들)를 통해 새로이 생성된 객체들은 항상 0 세대가 된다. 

Ex A)
이후 CLR에 의해 가비지 컬렉션이 발생하면 0 세대에 대해서만 가비지 컬렉션을 수행한다. 객체의 참조 그래프가 만들어지고 객체들이 컴팩션(compaction)되면 위에서 두 번째와 같은 힙이 구성된다. 

Ex B)
이때 0 세대의 GC동안 살아남은 객체 A, C, E, F 객체는 모두 1 세대로서 승급(promotion)되게 되는 것이다

Ex C)
추가적으로 객체 할당이 진행되면 새로운 객체들은 다시 0 세대 객체로서 할당
GC의 대상이 되는 객체는 3, 5 객체이다 
하지만 GC는 0 세대에 대해서만 발생했기 때문에 1 세대의 객체인 3은 가비지 컬렉션이 되지 않는다. 

EX D)
결론적으로 마지막 힙처럼 5 객체가 메모리 컴팩션에 의해 사라지게 되고 6 객체는 GC 동안 살아 남아 1세대로 승급하게 되는 것이다.

Ex)
A 
[1+, 2-, 3+, 4+, , , ,]
Gen0 {1, 2, 3, 4}

B 
[1+, 3+, 4+, , , , ,]
Gen1 {1, 3, 4}

C
[1+, 3-, 4+, 5-, 6+, , ,]
Gen1 {1, 3, 4}
Gen0 {5, 6}

D
[1+, 3-, 4+, 6+, , , ,]
Gen1 {1, 3, 4, 6}




3. GC 1 -----------------------------------------------------------------------------------------

1세대에 존재하는 객체는 절대로 메모리에서 사라지지 않는 것일까? 그렇지 않다.
시간이 흘러감에 따라 1 세대 힙의 크기도 점차로 커질 것이며 힙의 사용 가능한 메모리 영역 역시 줄어들 것이다.
 1 세대 늘어남에 따라 CLR 내부에 결정된 특정 한계에 도달하면(이 한계점은 버전마다 달라질 수 있으며 문서화되어 있지도 않다. 대개 1 세대 힙의 크기가 늘어나고 0 세대 힙의 크기가 줄어 들면 0 세대 힙을 늘이지만 0 세대는 일정 크기 이상 커지지 않는다)
GC는 0세대와 1세대에 대해서 가비지 컬렉션을 수행한다. 이렇게 0 세대에 대해서만 수행하는 가비지 컬렉션을 GC 0라고 하고 0 세대와 1 세대에 대해서 가비지 컬렉션을 수행하는 것을 GC 1 이라고 한다. 
GC 1 동안 살아남은 1 세대의 객체는 2 세대로 승급하며 GC 1 동안 살아남은 0 세대의 객체는 1 세대로 승급한다.


4. GC 2 (풀 가비지 컬렉션) -----------------------------------------------------------------------
2 세대에 존재하는 객체들은 가비지 컬렉터가 2세대를 가비지 컬렉션 하기 전까지는 힙에 남는다.
비슷하게 GC가 2세대를 가비지 컬렉션 하는 상황은 힙 상에 사용 가능한 공간이 줄어들어 GC 1을 수행해도 0세대 힙이 부족할 것 같은 상황에서 발생한다. 2세대 가비지 컬렉션은 항상 0세대 및 1세대 가비지 컬렉션을 포함하여 수행하기 때문에 2세대 가비지 컬렉션을 GC 2 혹은 풀 가비지 컬렉션(full garbage collection)이라고 한다.