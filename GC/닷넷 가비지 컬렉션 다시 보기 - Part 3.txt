http://www.simpleisbest.net/post/2011/04/11/Large-Object-Heap-Intro.aspx

LOH에 대해 이미 어느 정도 알고 계신 분들은 MSDN Magazine에서 (http://msdn.microsoft.com/en-us/magazine/cc534993.aspx)를 읽어 보시길 권장합니다

요약
- LOH에는 85000바이트 이상의 객체만 할당됨
- 메모리 할당 해제 방식과 유사하게 메모리 할당, 가비지 컬렉션을 수행
- LOH에 할당된 객체는 2세대 객체로 간주
- LOH 가비지 컬렉션과 SOH의 GC2은 같이 발생함

LOH (Large Object Heap)---------------------------------------------------------

LOH라 불리는 힙은 85,000 바이트 이상 상대적으로 커다란 객체가 할당되는 관리되는 힙(managed heap)의 한 부분이다. 
CLR(Common Language Runtime)은 힙을 크게 두 부분(SOH, LOH)으로 나누어 별도로 관리한다.
SOH는 Gen 0, Gen 1, Gen 2 힙을 말하는 것으로 85,000 바이트 이하의 객체들이 할당되고 나이를 먹다가 죽어가는 곳이다. 

먼저 LOH에 할당되는 객체들은 83KB 보다 큰 객체들이다. 
여기서 우리가 주의할 것은 단일 객체의 크기가 83KB 보다 큰 경우에만 LOH에 객체가 할당된다는 것이다.
예를 들어 다음 MyObject 클래스의 인스턴스는 LOH에 할당되지 않는다.
class MyObject
{
    private byte[] Data1 = new byte[32*1024];    // 32KB array
    private byte[] Data2 = new byte[92*1024];    // 92KB array
}


LOH는 어떻게 정리되는가?---------------------------------------------------------
LOH에 대해서도 GC는 가비지 컬렉션을 수행한다. 이 때 GC는 Gen 0, Gen 1, Gen 2의 관리되는 힙을 컬렉션 할 때와 전혀 다르게 작동한다.

LOH는 C/C++의 메모리 할당 및 해제 방식과 유사하게 메모리 할당과 가비지 컬렉션을 수행한다

어플리케이션이 커다란 메모리 할당을 요청하면  LOH 상에서 그 메모리를 할당 할 수 있는 빈 공간을 찾아(Free memory list 검사) 할당하며
GC가 LOH를 컬렉션 할 때에는 더 이상 사용하지 않는 객체들을 제거하는 스웹(sweap)만 할 뿐 객체들을 밀어 붙여서 빈 공간을 늘이는 컴팩션(compation)을 수행하지 않는다는 말이 되겠다.


왜 LOH는 스웹만을 하고 컴팩션은 하지 않는 걸까?
커다란 객체들을 컴팩션 하기 위해 객체들을 메모리 상에서 복사하는 비용이 꽤나 높기 때문이다.
많은 성능 테스트와 튜닝을 거쳐서 내린 결과가 “85000 바이트 보다 큰 객체들은 컴팩션으로 얻을 수 잇는 장점보다 메모리 복사로 인한 단점이 더 많다”는 것이고 이로 인해 SOH와는 작동 방식이 다른 LOH가 탄생한 것이 되겠다.

LOH에 대해 가비지 컬렉션이 수행되면 Gen0, Gen1, Gen2의 객체들과 동일한 방법으로 더 이상 사용 중이 아닌 객체들을 LOH에서도 검색하게 된다. 그리고 더 이상 사용 중이 아닌 객체는 사라지게 된다. 

LOH에는 늙은이만 산다!---------------------------------------------------------
LOH에 할당되는 객체들은 기본적으로 2세대 객체로 간주된다. 


LOH 사용 시 주의 사항---------------------------------------------------------
LOH는 SOH에 대한 할당에 비해 빠르지 않다
첫째로 LOH 상에서 빈 메모리 공간을 검색해야 하며 둘째로, 상대적으로 커다란 할당된 메모리의 내용을 0으로 초기화 해야 하기 때문이다.
빈 메모리 공간을 찾는 것은 그다지 큰 댓가를 요구하지 않지만 0으로 초기화하는 과정은 메모리 크기에 따라서 상당한 시간을 요구할 수도 있다.

LOH의 가비지 컬렉션은 GC 2의 일부로써 수행된다. 따라서 GC가 SOH에 대해 GC 2가 필요하다고 판단이 될 때 LOH도 덩달아 가비지 컬렉션이 되는 것이다. 
LOH에 할당된 객체는 GC 2가 발생해야만 정리가 되기 때문에 LOH에 할당된 객체는 동일한 시점에서 할당된 작은 객체들에 비해 더 오랫동안 메모리 공간을 차지하게 된다는 것을 고려해야한다.

반대로 LOH에 대해 많은 메모리 할당이 이루어져도 GC 2가 발생하기도 한다.
일반적으로 GC 2가 발생하는 주기는 GC 0 주기의 100 배 혹은 그 이상이 될 수도 있다. 하지만 LOH에 대한 빈번한 할당이 발생하면 더 짧은 주기로 GC 2가 수행되고 이로 인해 어플리케이션의 성능이 저하될 수도 있다

LOH는 SOH와 달리 메모리 조각(fragmentation)이 자주 발생한다.
LOH를 조금이라도 효율적으로 사용하고자 한다면 어플리케이션 초장에 커다란 배열을 한번에 미리 할당해 놓고 이 메모리의 부분을 버퍼로써 반복적으로 재사용 하는 것이 좋다.